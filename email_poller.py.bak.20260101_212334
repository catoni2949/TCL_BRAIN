#!/usr/bin/env python3
import os, json, ssl, imaplib
from pathlib import Path
from datetime import datetime, timezone

BASE = Path.home() / "TCL_BRAIN"
STATE = BASE / "state" / "imap_state.json"
INBOX_DROP = BASE / "inbox_drop"

IMAP_HOST = os.environ.get("TCL_IMAP_HOST", "").strip()
IMAP_USER = os.environ.get("TCL_IMAP_USER", "").strip()
IMAP_PASS = os.environ.get("TCL_IMAP_PASS", "").strip()
IMAP_FOLDER = os.environ.get("TCL_IMAP_FOLDER", "INBOX").strip()

def utc_now_z():
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

def load_state():
    if STATE.exists():
        try:
            return json.loads(STATE.read_text())
        except Exception:
            return {}
    return {}

def save_state(st):
    STATE.parent.mkdir(parents=True, exist_ok=True)
    STATE.write_text(json.dumps(st, ensure_ascii=False, indent=2))

def parse_headers(raw: bytes):
    sender = ""
    subject = ""
    for line in raw.decode("utf-8", "ignore").splitlines():
        if line.lower().startswith("from:"):
            sender = line.split(":", 1)[1].strip()
        elif line.lower().startswith("subject:"):
            subject = line.split(":", 1)[1].strip()
        if sender and subject:
            break
    return sender, subject

def main():
    if not (IMAP_HOST and IMAP_USER and IMAP_PASS):
        raise SystemExit("Missing IMAP env vars")

    INBOX_DROP.mkdir(parents=True, exist_ok=True)

    state = load_state()
    key = f"{IMAP_HOST}|{IMAP_USER}|{IMAP_FOLDER}"
    last_uid = int(state.get(key, 0))

    ctx = ssl.create_default_context()
    M = imaplib.IMAP4_SSL(IMAP_HOST, ssl_context=ctx)
    M.login(IMAP_USER, IMAP_PASS)
    M.select(IMAP_FOLDER)

    typ, data = M.uid("SEARCH", None, f"(UID {last_uid+1}:*)")
    if typ != "OK":
        M.logout()
        return

    uids = [int(x) for x in data[0].split()] if data and data[0] else []
    if not uids:
        print(f"{utc_now_z()} no new mail")
        M.logout()
        return

    events = []
    max_uid = last_uid

    for uid in uids[-200:]:
        typ, msgdata = M.uid("FETCH", str(uid), "(RFC822.HEADER)")
        if typ != "OK":
            continue

        raw = b"".join(p[1] for p in msgdata if isinstance(p, tuple))
        sender, subject = parse_headers(raw)

        events.append({
            "ts": utc_now_z(),
            "sender": sender,
            "subject": subject,
            "project": "",
            "waiting_status": None
        })

        max_uid = max(max_uid, uid)

    M.logout()

    if events:
        stamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        out = INBOX_DROP / f"imap_poll_{stamp}.jsonl"
        with out.open("w", encoding="utf-8") as f:
            for e in events:
                f.write(json.dumps(e, ensure_ascii=False) + "\n")

        state[key] = max_uid
        save_state(state)
        print(f"{utc_now_z()} wrote {len(events)} events -> {out.name}")
    else:
        print(f"{utc_now_z()} no parsable events")

if __name__ == "__main__":
    main()
