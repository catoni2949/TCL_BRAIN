#!/usr/bin/env python3
from typing import Optional
import os, json, time, uuid
from datetime import datetime, timezone
import msal
import requests

ROOT = os.path.dirname(os.path.abspath(__file__))
STATE_DIR = os.path.join(ROOT, "state")
INBOX_DROP = os.path.join(ROOT, "inbox_drop")

STATE_FILE = os.path.join(STATE_DIR, "email_poller_graph.state.json")
MSG_MAP_FILE = os.path.join(STATE_DIR, "email_poller_graph.msgid_to_uid.json")

GRAPH = "https://graph.microsoft.com/v1.0"

def utc_now_z() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

def ensure_dirs():
    os.makedirs(STATE_DIR, exist_ok=True)
    os.makedirs(INBOX_DROP, exist_ok=True)

def load_json(path, default):
    try:
        with open(path, "r") as f:
            return json.load(f)
    except Exception:
        return default

def save_json(path, obj):
    tmp = path + ".tmp"
    with open(tmp, "w") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)

def get_token(tenant: str, client_id: str, secret: str) -> str:
    app = msal.ConfidentialClientApplication(
        client_id=client_id,
        authority=f"https://login.microsoftonline.com/{tenant}",
        client_credential=secret,
    )
    tok = app.acquire_token_for_client(scopes=["https://graph.microsoft.com/.default"])
    if "access_token" not in tok:
        raise RuntimeError(f"TOKEN_FAIL {tok.get('error')} {tok.get('error_description')}")
    return tok["access_token"]

def graph_get(url: str, headers: dict, params: Optional[dict] = None) -> dict:
    r = requests.get(url, headers=headers, params=params, timeout=30)
    if r.status_code >= 400:
        raise RuntimeError(f"GRAPH_ERR status={r.status_code} body={r.text[:1200]}")
    return r.json()

def make_event(msg: dict, mailbox_upn: str, uid: int) -> dict:
    # Normalize sender
    frm = (msg.get("from") or {}).get("emailAddress") or {}
    sender_addr = frm.get("address") or mailbox_upn
    subject = msg.get("subject") or "(no subject)"

    # Use receivedDateTime if present, else now
    ts = msg.get("receivedDateTime") or utc_now_z()

    # Build a stable "project" grouping key based on mailbox
    project = f"EMAIL/{mailbox_upn}"

    return {
        "ts": ts.replace(".0000000Z", "Z"),  # sometimes Graph returns fractional seconds
        "sender": sender_addr,
        "subject": subject,
        "project": project,
        "waiting_status": "neutral",
        "uid": uid,
        "graph_message_id": msg.get("id"),
        "mailbox": mailbox_upn,
    }

def main():
    ensure_dirs()

    tenant = os.environ["TCL_TENANT_ID"]
    client_id = os.environ["TCL_CLIENT_ID"]
    secret = os.environ["TCL_CLIENT_SECRET"]
    mailbox_upn = os.environ["TEST_MAILBOX_UPN"]

    st = load_json(STATE_FILE, {})
    msg_map = load_json(MSG_MAP_FILE, {"next_uid": 1, "seen": {}})

    token = get_token(tenant, client_id, secret)
    headers = {"Authorization": f"Bearer {token}"}

    # Delta query endpoint
    # Start with deltaLink if we have it; else initialize a delta query
    delta_link = st.get("delta_link")
    if delta_link:
        url = delta_link
        params = None
    else:
        url = f"{GRAPH}/users/{mailbox_upn}/mailFolders/AQMkADM3OWFmYTI2LTViMTgtNGU2NgAtYjZlOC00OWZhMDVhMDY4MTgALgAAA1AQdFjC8ChIto0k0TG1JdABAM1pjPqLFiFIlCQMHY72CIUAAAIBDAAAAA==/messages/delta"
        params = {
            "$select": "id,subject,receivedDateTime,from",
            "$top": "50",
            "$orderby": "receivedDateTime desc",
        }

    new_events = []
    pages = 0

    while True:
        pages += 1
        data = graph_get(url, headers, params=params)

        for msg in data.get("value", []):
            mid = msg.get("id")
            if not mid:
                continue
            if mid in msg_map["seen"]:
                continue

            uid = int(msg_map["next_uid"])
            msg_map["next_uid"] = uid + 1
            msg_map["seen"][mid] = uid

            new_events.append(make_event(msg, mailbox_upn, uid))

        # Continue paging
        next_link = data.get("@odata.nextLink")
        if next_link:
            url = next_link
            params = None
            continue

        # Persist new delta link when provided
        new_delta = data.get("@odata.deltaLink")
        if new_delta:
            st["delta_link"] = new_delta
            st["updated_utc"] = utc_now_z()

        break

    save_json(STATE_FILE, st)
    save_json(MSG_MAP_FILE, msg_map)

    if not new_events:
        print(f"{utc_now_z()} no new messages (pages={pages})")
        return

    # Write one drop file (jsonl) for watcher ingestion
    stamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
    fname = f"email_poll_{mailbox_upn.replace('@','_at_')}_{stamp}_{uuid.uuid4().hex[:8]}.jsonl"
    out_path = os.path.join(INBOX_DROP, fname)

    with open(out_path, "w") as f:
        for e in new_events:
            f.write(json.dumps(e, ensure_ascii=False) + "\n")

    print(f"{utc_now_z()} wrote {len(new_events)} events -> inbox_drop/{fname}")

if __name__ == "__main__":
    main()
